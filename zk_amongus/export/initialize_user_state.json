{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":18242183730999201571,"abi":{"parameters":[{"name":"player_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"encrypt_secret","type":{"kind":"field"},"visibility":"private"},{"name":"mask_secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"UserState","fields":[{"name":"my_player_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"private_info","type":{"kind":"struct","path":"player_state::PlayerPrivateInfo","fields":[{"name":"role","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypt_secret","type":{"kind":"field"}},{"name":"mask_secret","type":{"kind":"field"}},{"name":"voted_for_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"encrypt_secret","type":{"kind":"field"}},{"name":"mask_secret","type":{"kind":"field"}},{"name":"all_players_public_view","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"player_state::PlayerPublicInfo","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"game_player_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"section_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"visible_sections","type":{"kind":"array","length":9,"type":{"kind":"integer","sign":"unsigned","width":32}}}]},"visibility":"private"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"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","debug_symbols":"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","file_map":{"61":{"source":"use dep::std;\nuse std::hash::poseidon2::Poseidon2;\n\n// Use specific imports from mpclib\nuse mpclib::selective_disclosure::selective_disclosure::{\n    consume_round_commitments, create_round_commitments, RoundState, UserOutputState,\n};\n\n// Declare core modules for Among Us game\nmod player_state;\nmod validate_move;\nmod update_vision;\n// mod api; // Comment out if moving logic directly here\n\n// Re-export necessary items for use within the crate (e.g., in api.nr) or potentially externally\n// Ensure items being re-exported are marked `pub` in their respective modules\npub use player_state::{ PlayerPublicInfo, PlayerPrivateInfo };\npub use player_state::{ MAP_SIZE, NUM_PLAYERS, MAX_VISIBLE_SECTIONS }; \npub use player_state::{ ROLE_CREW, ROLE_IMPOSTER, STATUS_ALIVE, STATUS_DEAD }; // Re-export constants\npub use validate_move::validate_adjacent_move;\npub use update_vision::calculate_visible_sections;\n\n// Keep API re-export separate if preferred\n// pub use api::{*}; // Removed wildcard export - access via api::function_name\n\n// Placeholder example function (remove or move later)\n// fn example_move_proof(...) -> UserState { ... }\n\n// NOTE: Old chess-specific code, structs (GameState, MoveHashes, etc.) \n// and functions (move, consume_opponent_move_and_update_game_state, commit_to_user_secrets)\n// defined directly in the old lib.nr have been removed.\n// Their equivalents should be defined within the `api` module, \n// using the new structs and functions from player_state, validate_move, update_vision.\n\n// --- Core Types (Mirrors fog_of_war_chess structure) ---\n\ntype RoundMpcState = RoundState<64, NUM_PLAYERS>;\npub struct GameState {\n    pub game_ended: bool, // Or maybe an enum: Ongoing, CrewWin, ImposterWin\n    pub turn_count: u32, \n    // Store the public state of all players\n    pub all_players_public: [PlayerPublicInfo; NUM_PLAYERS],\n    // Add other global state: e.g., emergency meeting status, task progress?\n    pub mpc_state: RoundMpcState, // Re-add MPC state\n}\n\nimpl std::default::Default for GameState {\n    fn default() -> Self {\n        let mut players = [PlayerPublicInfo::default(); NUM_PLAYERS];\n        for i in 0..NUM_PLAYERS {\n            players[i].game_player_index = i;\n            // Role assignment removed - Roles are private now\n            // Actual roles will be determined during initialization (e.g., via shuffle or predetermined secret)\n            players[i].section_id = 36; // Example start section\n            players[i].status = STATUS_ALIVE; \n            players[i].player_id = i as Field; \n        }\n        GameState { \n            game_ended: false, \n            turn_count: 0, \n            all_players_public: players,\n            mpc_state: RoundMpcState::default() \n        }\n    }\n}\n\n// Add commit_to_user_secrets based on user example\nimpl GameState {\n    // Use mpc_state.hash() as confirmed from mpclib source\n    pub fn hash(self) -> Field {\n        self.mpc_state.hash() \n    }\n\n    // #[export] // Cannot export from impl block\n    // Internal logic for committing secrets\n    fn commit_secrets_logic(\n        mut self, \n        encrypt_secret: Field,\n        mask_secret: Field,\n        player_index: u32,\n    ) -> GameState {\n        let encrypt_buffer = [encrypt_secret];\n        let encrypt_hash = Poseidon2::hash(encrypt_buffer, 1);\n        let mask_buffer = [mask_secret];\n        let mask_hash = Poseidon2::hash(mask_buffer, 1);\n        self.mpc_state.user_encrypt_secret_hashes[player_index] = encrypt_hash;\n        self.mpc_state.user_mask_secret_hashes[player_index] = mask_hash;\n        self \n    }\n}\n\n// Standalone exported function to commit secrets (mirrors internal logic)\n#[export]\npub fn commit_to_user_secrets(\n    game_state: GameState, \n    encrypt_secret: Field,\n    mask_secret: Field,\n    player_index: u32,\n) -> GameState {\n    // Call the internal logic\n    game_state.commit_secrets_logic(encrypt_secret, mask_secret, player_index)\n}\n\n// Adapted MoveData for Among Us\npub struct MoveData {\n    pub target_section: u32,\n}\n\n// Adapted UserState for Among Us (uses internal modules)\npub struct UserState {\n     pub my_player_index: u32, \n     pub private_info: PlayerPrivateInfo, // Now includes role\n     pub encrypt_secret: Field, // Add secret for MPC\n     pub mask_secret: Field,    // Add secret for MPC\n     // Player's view of the public state (might differ from global GameState due to visibility)\n     pub all_players_public_view: [PlayerPublicInfo; NUM_PLAYERS], \n     pub visible_sections: [u32; MAX_VISIBLE_SECTIONS], \n     // Maybe add: pub task_list: ..., pub kill_cooldown: ...\n}\n\n// Default UserState needs careful initialization based on player index\nimpl std::default::Default for UserState {\n     fn default() -> Self {\n         // Default state is somewhat meaningless without a player index context\n         // initialize_user_state function is better.\n         let invalid_section_sentinel: u32 = MAP_SIZE * MAP_SIZE; \n         let default_visible = [invalid_section_sentinel; MAX_VISIBLE_SECTIONS]; \n         UserState {\n             my_player_index: NUM_PLAYERS, // Sentinel for invalid/default\n             private_info: PlayerPrivateInfo::default(),\n             encrypt_secret: 0, // Default secret (should be replaced)\n             mask_secret: 0,    // Default secret (should be replaced)\n             all_players_public_view: [PlayerPublicInfo::default(); NUM_PLAYERS],\n             visible_sections: default_visible,\n         }\n     }\n}\n\n// Add an encode method to UserState\nimpl UserState {\n    // Encodes the player's view of everyone's public state (section and status)\n    // into a [Field; 64] buffer for commitment.\n    // Player i's section_id maps to index 2*i\n    // Player i's status maps to index 2*i + 1\n    // Pass self by value as workaround for ownership flag issue\n    pub fn encode_state_for_commitment(self) -> [Field; 64] {\n        let mut encoded = [0; 64];\n        // Ensure we don't write past the buffer if NUM_PLAYERS > 32\n        let max_players_to_encode = if NUM_PLAYERS * 2 > 64 { 32 } else { NUM_PLAYERS };\n\n        for i in 0..max_players_to_encode {\n            // Encode section_id for player i at index 2*i\n            encoded[2 * i] = self.all_players_public_view[i].section_id as Field;\n            // Encode status for player i at index 2*i + 1\n            encoded[2 * i + 1] = self.all_players_public_view[i].status as Field;\n            // Role is private and not encoded here.\n            // Player ID is implicitly known by index.\n        }\n        // Indices from max_players_to_encode*2 up to 63 remain 0.\n        encoded\n    }\n}\n\n// Adapted MoveHashes\npub struct MoveHashes {\n    pub input_game_state_hash: Field, // Hash of GameState before move\n    pub input_user_state_hash: Field, // Hash of UserState before move\n    pub output_game_state_hash: Field, // Hash of GameState after move\n    pub output_user_state_hash: Field, // Hash of UserState after move\n}\n\nimpl std::default::Default for MoveHashes {\n    fn default() -> Self {\n        MoveHashes {\n            input_game_state_hash: 0,\n            input_user_state_hash: 0,\n            output_game_state_hash: 0,\n            output_user_state_hash: 0,\n        }\n    }\n}\n\n// --- Core Functions (Mirrors fog_of_war_chess structure) ---\n\n// Public move function: takes current state, user state, move data, and player index\n// Returns the new global state and relevant hashes\n#[export]\npub fn move(\n    input_state: GameState,    // Changed: Removed 'mut', renamed to input_state\n    user_state: UserState,\n    move_data: MoveData\n) -> (GameState, MoveHashes) { // Return type remains the same\n\n    let player_index = user_state.my_player_index;\n    // Calculate input hashes\n    let input_game_state_hash = input_state.hash();\n    // Placeholder for user state hash calculation\n    let input_user_state_buffer = [user_state.private_info.encrypt_secret, user_state.private_info.mask_secret];\n    let input_user_state_hash = Poseidon2::hash(input_user_state_buffer, 2);\n\n    // 1. Assertions and Pre-conditions\n    assert_eq(input_state.game_ended, false, \"Game already ended\");\n    //assert_eq(user_state.my_player_index, player_index, \"UserState does not match player_index\");\n    // Ensure the player making the move is alive in their own view\n    let my_public_info_view = user_state.all_players_public_view[player_index];\n    assert(my_public_info_view.status == STATUS_ALIVE, \"Cannot move when dead\"); // Check against constant\n\n    // 2. Validate Move Legality (using internal module)\n    let current_section = my_public_info_view.section_id;\n    let target_section = move_data.target_section;\n    let is_valid = validate_adjacent_move(current_section, target_section, MAP_SIZE); // Re-use validation\n    assert(is_valid, \"Invalid move: Target section not adjacent\"); // Assert the result\n\n    // 3. Calculate *Intended* Next Player State (for commitment)\n    // This calculates what the user_state *would* look like after the move,\n    // primarily for determining visibility for the commitment mask.\n    // It does NOT modify the input user_state.\n    let mut intended_next_user_state = user_state; // Start with current state\n    intended_next_user_state.all_players_public_view[player_index].section_id = target_section; // Update position\n    intended_next_user_state.visible_sections = calculate_visible_sections(target_section, MAP_SIZE); // Update vision\n\n    // 4. Prepare MPC Commitment Data\n    // Encode the player's *intended* view of the public state after the move\n    let encoded_state_to_commit: [Field; 64] = intended_next_user_state.encode_state_for_commitment();\n\n    // Create visibility mask based on the *intended* post-move state\n    let mut visibility_fields: [Field; 64] = [0; 64]; // 0 = hide, 1 = reveal\n    for i in 0..NUM_PLAYERS { // Iterate through all players (global indices)\n        let opponent_global_index = i;\n        let opponent_section = intended_next_user_state.all_players_public_view[opponent_global_index].section_id;\n        let mut opponent_is_visible = false;\n        for j in 0..MAX_VISIBLE_SECTIONS {\n            if intended_next_user_state.visible_sections[j] == opponent_section {\n                opponent_is_visible = true;\n            }\n        }\n\n        // If the opponent is visible *or* if it's the player themselves, mark their fields revealable\n        if opponent_is_visible | (opponent_global_index == player_index) {\n             // Mark section_id (index 2*i) and status (index 2*i + 1) as revealable\n            visibility_fields[2 * opponent_global_index] = 1;\n            visibility_fields[2 * opponent_global_index + 1] = 1;\n        }\n    }\n    // Ensure player always reveals their own info\n    if player_index < NUM_PLAYERS { // Basic bounds check\n        visibility_fields[2 * player_index] = 1;     // Reveal own section\n        visibility_fields[2 * player_index + 1] = 1; // Reveal own status\n    }\n\n    // 5. Create MPC Commitments\n    let mut output_commitments: UserOutputState<64, NUM_PLAYERS> = create_round_commitments(\n        encoded_state_to_commit,\n        visibility_fields,\n        user_state.private_info.encrypt_secret, // Use secrets from the *input* user_state\n        user_state.private_info.mask_secret,\n        input_state.mpc_state, // Pass the *immutable* input mpc_state\n        player_index\n    );\n\n    // 6. Calculate the next MPC state using the input state's mpc_state\n    let mut output_mpc_state = input_state.mpc_state;\n    //.update2(output_commitments, player_index);\n\n    output_mpc_state.round_number += 1;\n    output_mpc_state.previous_output_states[player_index] = output_commitments;\n\n    // 7. Create the output GameState\n    // Create a mutable copy of the public player info to update it\n    let mut updated_all_players_public = input_state.all_players_public;\n    updated_all_players_public[player_index].section_id = target_section;\n\n    let output_game_state = GameState {\n        all_players_public: updated_all_players_public, // Use the updated copy\n        game_ended: input_state.game_ended, // For now, assume move doesn't end game\n        mpc_state: output_mpc_state,        // Use the newly calculated MPC state\n        turn_count: input_state.turn_count + 1, // Increment turn count\n    };\n\n    // 8. Calculate Output Hashes\n    let output_game_state_hash = output_game_state.hash();\n    // User state hash should reflect the state *before* consumption,\n    // which is encoded in `encoded_state_to_commit`.\n    let output_user_state_hash = Poseidon2::hash(encoded_state_to_commit, encoded_state_to_commit.len());\n\n    // 9. Return updated global state and hashes\n    let move_hashes = MoveHashes {\n        input_game_state_hash: input_game_state_hash,\n        input_user_state_hash: input_user_state_hash, // Hash of input user state secrets\n        output_game_state_hash: output_game_state_hash, // Hash of the new game state\n        output_user_state_hash: output_user_state_hash, // Hash of the committed user view\n    };\n\n    (output_game_state, move_hashes)\n}\n\n// Initializer for GameState\n#[export]\npub fn empty_game_state() -> GameState {\n     GameState::default() // IMPLICIT return\n}\n\n// Initializer for UserState\n#[export]\npub fn initialize_user_state(player_index: u32, encrypt_secret: Field, mask_secret: Field) -> UserState {\n    let my_role = if player_index < 2 { ROLE_IMPOSTER } else { ROLE_CREW };\n    let initial_global_state = GameState::default();\n    let my_start_section = initial_global_state.all_players_public[player_index].section_id;\n    let initial_visible_sections = calculate_visible_sections(my_start_section, MAP_SIZE);\n    let mut initial_view = [PlayerPublicInfo::default(); NUM_PLAYERS];\n    \n    for i in 0..NUM_PLAYERS {\n        let other_player_global_info = initial_global_state.all_players_public[i];\n        let other_player_section = other_player_global_info.section_id;\n        let mut player_can_be_seen = false; \n        for j in 0..MAX_VISIBLE_SECTIONS {\n             if initial_visible_sections[j] == other_player_section {\n                 player_can_be_seen = true;\n             }\n        }\n\n        if i == player_index {\n            initial_view[i] = other_player_global_info;\n        } else { \n            if player_can_be_seen {\n                 initial_view[i] = other_player_global_info;\n            } else {\n                let mut masked_info = PlayerPublicInfo::default();\n                masked_info.game_player_index = i; \n                masked_info.section_id = MAP_SIZE * MAP_SIZE; \n                masked_info.status = other_player_global_info.status; \n                initial_view[i] = masked_info; \n            }\n        }\n    }\n\n    let user_state = UserState {\n        my_player_index: player_index,\n        private_info: PlayerPrivateInfo { \n            role: my_role, \n            encrypt_secret: encrypt_secret, \n            mask_secret: mask_secret, \n            voted_for_index: NUM_PLAYERS \n        },\n        encrypt_secret: encrypt_secret, \n        mask_secret: mask_secret,\n        all_players_public_view: initial_view, \n        visible_sections: initial_visible_sections,\n    };\n    \n     user_state \n}\n\n// Function to update a player's local UserState based on the global GameState's MPC commitments\n#[export]\npub fn consume_global_state_and_update_local_view(\n    current_local_user_state: UserState, \n    global_game_state: GameState,      \n) -> UserState {                        \n\n    let my_player_index = current_local_user_state.my_player_index;\n\n    // --- Consume Commitments --- \n    let revealed_state_data_nested: [[Option<Field>; 64]; NUM_PLAYERS - 1] = consume_round_commitments(\n        current_local_user_state.mask_secret, \n        global_game_state.mpc_state,             \n        my_player_index \n    );\n\n    // --- Update View --- \n    let mut updated_user_state = current_local_user_state;\n    \n    // Keep track of which opponent index maps to which nested array index\n    let mut opponent_array_index = 0; \n\n    for opponent_global_index in 0..NUM_PLAYERS {\n        if opponent_global_index != my_player_index {\n            // Get the revealed Option<Field> array for this specific opponent\n            let revealed_opponent_options: [Option<Field>; 64] = revealed_state_data_nested[opponent_array_index];\n            \n            // Get a mutable reference to our current view of this opponent\n            let mut current_opponent_view = updated_user_state.all_players_public_view[opponent_global_index];\n\n            // Decode revealed section_id (encoded at index 2 * opponent_global_index)\n            let section_index = 2 * opponent_global_index;\n            if section_index < 64 { // Bounds check\n                if revealed_opponent_options[section_index].is_some() {\n                    // Revealed: Update section_id in our view\n                    current_opponent_view.section_id = revealed_opponent_options[section_index].unwrap_unchecked() as u32;\n                } // else: Not revealed, keep existing section_id view (potentially masked/stale)\n            }\n\n            // Decode status (encoded at index 2 * opponent_global_index + 1)\n            let status_index = section_index + 1;\n            if status_index < 64 { // Bounds check\n                if revealed_opponent_options[status_index].is_some() {\n                    // Revealed: Update status in our view\n                    current_opponent_view.status = revealed_opponent_options[status_index].unwrap_unchecked() as u32;\n                } // else: Not revealed, keep existing status view (potentially masked/stale)\n            }\n\n            // NOTE: Other fields (indices not 2*i or 2*i+1) were not encoded in the first place,\n            // so we don't need to decode them.\n\n            // --- Update the main view array with the potentially updated opponent view ---\n            updated_user_state.all_players_public_view[opponent_global_index] = current_opponent_view;\n            \n            // Increment index for the revealed_state_data_nested array\n            opponent_array_index += 1;\n        }\n    }\n\n    // --- Update Our Own Public View Info ---\n    // Ensure our own view reflects the latest public global state for ourselves,\n    // as our state isn't revealed via consume_round_commitments.\n    updated_user_state.all_players_public_view[my_player_index] = global_game_state.all_players_public[my_player_index];\n\n    // --- Recalculate Visibility --- \n    let my_updated_section = updated_user_state.all_players_public_view[my_player_index].section_id;\n    updated_user_state.visible_sections = calculate_visible_sections(my_updated_section, MAP_SIZE);\n\n    // --- Optional: Re-masking based on new visibility (can be complex) ---\n    // This logic might be needed if players can move *out* of view and their info should be hidden again.\n    // For now, we rely on the initial decoding providing the correct visible state.\n\n    // --- Return Updated State --- \n    updated_user_state \n}\n","path":"/Users/lago/Desktop/joaolago1113/fogofwarr/zk_amongus/src/lib.nr"},"63":{"source":"use crate::player_state::{MAP_SIZE, MAX_VISIBLE_SECTIONS, NUM_PLAYERS};\nuse dep::std;\n\n// Calculates the set of visible sections for a player based on simple adjacency.\n// Includes the player's own section.\n// Returns an array of size MAX_VISIBLE_SECTIONS, padded with invalid_section_sentinel for invalid/out-of-bounds sections.\npub fn calculate_visible_sections(\n    player_section: u32, \n    map_size: u32\n) -> [u32; MAX_VISIBLE_SECTIONS] {\n    \n    let invalid_section_sentinel: u32 = map_size * map_size; // Use same sentinel as default\n    let mut visible_sections = [invalid_section_sentinel; MAX_VISIBLE_SECTIONS];\n    let mut visible_count: u32 = 0; \n\n    let player_x: u32 = player_section % map_size;\n    let player_y: u32 = player_section / map_size;\n\n    // Iterate through the 3x3 grid centered on the player\n    for y_offset_idx in 0..3 { // y_offset = -1, 0, 1 maps to index 0, 1, 2\n        for x_offset_idx in 0..3 { // x_offset = -1, 0, 1 maps to index 0, 1, 2\n            let y_offset: i64 = (y_offset_idx as i64) - 1;\n            let x_offset: i64 = (x_offset_idx as i64) - 1;\n\n            let current_x_signed: i64 = (player_x as i64) + x_offset;\n            let current_y_signed: i64 = (player_y as i64) + y_offset;\n\n            // Boundary checks\n            if current_x_signed >= 0 & current_x_signed < (map_size as i64) & \n               current_y_signed >= 0 & current_y_signed < (map_size as i64) \n            {\n                // Convert back to u32 if within bounds\n                let current_x = current_x_signed as u32;\n                let current_y = current_y_signed as u32;\n                let section_id = current_y * map_size + current_x;\n                \n                // Add to visible sections if there's space\n                if visible_count < MAX_VISIBLE_SECTIONS {\n                    visible_sections[visible_count] = section_id;\n                    visible_count = visible_count + 1;\n                }\n            }\n        }\n    }\n\n    visible_sections\n}\n\n// Test case (replace old ones)\n#[test]\nfn test_visibility_center() {\n    let map_s: u32 = 8;\n    let invalid_sentinel: u32 = map_s * map_s;\n    // Center section for 8x8 is 27 (3,3) or 36 (4,4). Let's use 36.\n    let center_section: u32 = (map_s / 2) * map_s + (map_s / 2);\n    let visible = calculate_visible_sections(center_section, map_s);\n    \n    // Expected sections for center (4,4) are: 27, 28, 29, 35, 36, 37, 43, 44, 45\n    let expected = [27, 28, 29, 35, 36, 37, 43, 44, 45];\n    let mut count = 0;\n    for i in 0..MAX_VISIBLE_SECTIONS {\n        if visible[i] != invalid_sentinel { // Use sentinel for check\n            let mut found = false;\n            for j in 0..expected.len() {\n                if visible[i] == expected[j] {\n                    found = true;\n                }\n            }\n            // Check after inner loop completes\n            assert(found, \"Visible section not in expected list\");\n            count += 1;\n        }\n    }\n    assert(count == expected.len(), \"Incorrect number of visible sections\");\n}\n\n#[test]\nfn test_visibility_corner() {\n    let map_s: u32 = 8;\n    let invalid_sentinel: u32 = map_s * map_s;\n    let corner_section: u32 = 0; // Top-left corner (0,0)\n    let visible = calculate_visible_sections(corner_section, map_s);\n    \n    // Expected sections for corner (0,0) are: 0, 1, 8, 9\n    let expected = [0, 1, 8, 9];\n    let mut count = 0;\n    let mut sorted_visible = [invalid_sentinel; MAX_VISIBLE_SECTIONS]; // Use sentinel\n    let mut k: u32 = 0; // Ensure k is u32\n\n    // Collect valid visible sections\n    for i in 0..MAX_VISIBLE_SECTIONS {\n         if visible[i] != invalid_sentinel { // Use sentinel\n             assert(k < MAX_VISIBLE_SECTIONS, \"Exceeded visible section buffer\"); // Safety check\n             sorted_visible[k] = visible[i];\n             k += 1;\n         }\n    }\n     // Basic check for count and presence\n     assert(k == (expected.len() as u32), \"Incorrect number of visible sections for corner\");\n     for i in 0..expected.len() {\n         let mut found = false;\n         for j in 0..k {\n             if sorted_visible[j] == expected[i] {\n                 found = true;\n             }\n         }\n         // Check after inner loop completes\n         assert(found, \"Expected corner section not found\");\n     }\n}\n\n// Remove old chess vision functions and tests\n// pub(crate) fn update_vision(...) { ... }\n// fn update_vision_for_pawn(...) { ... }\n// #[test] fn test_piece_data() { ... }\n","path":"/Users/lago/Desktop/joaolago1113/fogofwarr/zk_amongus/src/update_vision.nr"}},"names":["initialize_user_state"],"brillig_names":["directive_integer_quotient","directive_invert"]}