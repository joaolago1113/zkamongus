{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":12592845496430841841,"abi":{"parameters":[{"name":"game_state","type":{"kind":"struct","path":"GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"all_players_public","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"player_state::PlayerPublicInfo","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"game_player_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"section_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"mpclib::selective_disclosure::selective_disclosure::RoundState","fields":[{"name":"round_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":3,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":3,"type":{"kind":"field"}}},{"name":"previous_output_states","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"mpclib::selective_disclosure::selective_disclosure::UserOutputState","fields":[{"name":"ciphertext","type":{"kind":"struct","path":"mpclib::common::crypto::Ciphertext","fields":[{"name":"data","type":{"kind":"array","length":128,"type":{"kind":"field"}}}]}},{"name":"mask_commitments","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}}},{"name":"user_updated_mask_commitments","type":{"kind":"array","length":3,"type":{"kind":"array","length":64,"type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}}}}]}}}]}}]},"visibility":"private"},{"name":"encrypt_secret","type":{"kind":"field"},"visibility":"private"},{"name":"mask_secret","type":{"kind":"field"},"visibility":"private"},{"name":"player_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"all_players_public","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"player_state::PlayerPublicInfo","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"game_player_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"section_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"mpclib::selective_disclosure::selective_disclosure::RoundState","fields":[{"name":"round_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":3,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":3,"type":{"kind":"field"}}},{"name":"previous_output_states","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"mpclib::selective_disclosure::selective_disclosure::UserOutputState","fields":[{"name":"ciphertext","type":{"kind":"struct","path":"mpclib::common::crypto::Ciphertext","fields":[{"name":"data","type":{"kind":"array","length":128,"type":{"kind":"field"}}}]}},{"name":"mask_commitments","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}}},{"name":"user_updated_mask_commitments","type":{"kind":"array","length":3,"type":{"kind":"array","length":64,"type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}}}}]}}}]}}]},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"7ZTRCoMgFIbfxesu1KNpvcoYw8qGIBZWgxF791mUNBrbxXY1duc55/M/8CGOqNLFcD4ZVzcdyg8jsk2petO4UI1ISJibXavcVHe98j3KQXKaIO2q6SjhlqDaWI3ylNySPUwFWWHA/A3M04VlFEeU8idoiM0WlgqA1zARYg0mIuNvYByTCU7lFj4mwQn7O9k54X8nOyfp505ARJhh+AEn4nMnjEB0stkQ4HmD/MKGLG7g7OElHkNReGOtOZ+2P2VoX5Q3qrB6KevBlZtpf23XyXq/9U2pq8HrKWmehfg7","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"use dep::std;\nuse std::hash::poseidon2::Poseidon2;\n\n// Use specific imports from mpclib\nuse mpclib::selective_disclosure::selective_disclosure::{\n    consume_round_commitments, create_round_commitments, RoundState, UserOutputState,\n};\n\n// Declare core modules for Among Us game\nmod player_state;\nmod validate_move;\nmod update_vision;\n// mod api; // Comment out if moving logic directly here\n\n// Re-export necessary items for use within the crate (e.g., in api.nr) or potentially externally\n// Ensure items being re-exported are marked `pub` in their respective modules\npub use player_state::{ PlayerPublicInfo, PlayerPrivateInfo };\npub use player_state::{ MAP_SIZE, NUM_PLAYERS, MAX_VISIBLE_SECTIONS }; \npub use player_state::{ ROLE_CREW, ROLE_IMPOSTER, STATUS_ALIVE, STATUS_DEAD }; // Re-export constants\npub use validate_move::validate_adjacent_move;\npub use update_vision::calculate_visible_sections;\n\n// Keep API re-export separate if preferred\n// pub use api::{*}; // Removed wildcard export - access via api::function_name\n\n// Placeholder example function (remove or move later)\n// fn example_move_proof(...) -> UserState { ... }\n\n// NOTE: Old chess-specific code, structs (GameState, MoveHashes, etc.) \n// and functions (move, consume_opponent_move_and_update_game_state, commit_to_user_secrets)\n// defined directly in the old lib.nr have been removed.\n// Their equivalents should be defined within the `api` module, \n// using the new structs and functions from player_state, validate_move, update_vision.\n\n// --- Core Types (Mirrors fog_of_war_chess structure) ---\n\ntype RoundMpcState = RoundState<64, NUM_PLAYERS>;\npub struct GameState {\n    pub game_ended: bool, // Or maybe an enum: Ongoing, CrewWin, ImposterWin\n    pub turn_count: u32, \n    // Store the public state of all players\n    pub all_players_public: [PlayerPublicInfo; NUM_PLAYERS],\n    // Add other global state: e.g., emergency meeting status, task progress?\n    pub mpc_state: RoundMpcState, // Re-add MPC state\n}\n\nimpl std::default::Default for GameState {\n    fn default() -> Self {\n        let mut players = [PlayerPublicInfo::default(); NUM_PLAYERS];\n        for i in 0..NUM_PLAYERS {\n            players[i].game_player_index = i;\n            // Role assignment removed - Roles are private now\n            // Actual roles will be determined during initialization (e.g., via shuffle or predetermined secret)\n            players[i].section_id = 36; // Example start section\n            players[i].status = STATUS_ALIVE; \n            players[i].player_id = i as Field; \n        }\n        GameState { \n            game_ended: false, \n            turn_count: 0, \n            all_players_public: players,\n            mpc_state: RoundMpcState::default() \n        }\n    }\n}\n\n// Add commit_to_user_secrets based on user example\nimpl GameState {\n    // Use mpc_state.hash() as confirmed from mpclib source\n    pub fn hash(self) -> Field {\n        self.mpc_state.hash() \n    }\n\n    // #[export] // Cannot export from impl block\n    // Internal logic for committing secrets\n    fn commit_secrets_logic(\n        mut self, \n        encrypt_secret: Field,\n        mask_secret: Field,\n        player_index: u32,\n    ) -> GameState {\n        let encrypt_buffer = [encrypt_secret];\n        let encrypt_hash = Poseidon2::hash(encrypt_buffer, 1);\n        let mask_buffer = [mask_secret];\n        let mask_hash = Poseidon2::hash(mask_buffer, 1);\n        self.mpc_state.user_encrypt_secret_hashes[player_index] = encrypt_hash;\n        self.mpc_state.user_mask_secret_hashes[player_index] = mask_hash;\n        self \n    }\n}\n\n// Standalone exported function to commit secrets (mirrors internal logic)\n#[export]\npub fn commit_to_user_secrets(\n    game_state: GameState, \n    encrypt_secret: Field,\n    mask_secret: Field,\n    player_index: u32,\n) -> GameState {\n    // Call the internal logic\n    game_state.commit_secrets_logic(encrypt_secret, mask_secret, player_index)\n}\n\n// Adapted MoveData for Among Us\npub struct MoveData {\n    pub target_section: u32,\n}\n\n// Adapted UserState for Among Us (uses internal modules)\npub struct UserState {\n     pub my_player_index: u32, \n     pub private_info: PlayerPrivateInfo, // Now includes role\n     pub encrypt_secret: Field, // Add secret for MPC\n     pub mask_secret: Field,    // Add secret for MPC\n     // Player's view of the public state (might differ from global GameState due to visibility)\n     pub all_players_public_view: [PlayerPublicInfo; NUM_PLAYERS], \n     pub visible_sections: [u32; MAX_VISIBLE_SECTIONS], \n     // Maybe add: pub task_list: ..., pub kill_cooldown: ...\n}\n\n// Default UserState needs careful initialization based on player index\nimpl std::default::Default for UserState {\n     fn default() -> Self {\n         // Default state is somewhat meaningless without a player index context\n         // initialize_user_state function is better.\n         let invalid_section_sentinel: u32 = MAP_SIZE * MAP_SIZE; \n         let default_visible = [invalid_section_sentinel; MAX_VISIBLE_SECTIONS]; \n         UserState {\n             my_player_index: NUM_PLAYERS, // Sentinel for invalid/default\n             private_info: PlayerPrivateInfo::default(),\n             encrypt_secret: 0, // Default secret (should be replaced)\n             mask_secret: 0,    // Default secret (should be replaced)\n             all_players_public_view: [PlayerPublicInfo::default(); NUM_PLAYERS],\n             visible_sections: default_visible,\n         }\n     }\n}\n\n// Add an encode method to UserState\nimpl UserState {\n    // Encodes the player's view of everyone's public state (section and status)\n    // into a [Field; 64] buffer for commitment.\n    // Player i's section_id maps to index 2*i\n    // Player i's status maps to index 2*i + 1\n    // Pass self by value as workaround for ownership flag issue\n    pub fn encode_state_for_commitment(self) -> [Field; 64] {\n        let mut encoded = [0; 64];\n        // Ensure we don't write past the buffer if NUM_PLAYERS > 32\n        let max_players_to_encode = if NUM_PLAYERS * 2 > 64 { 32 } else { NUM_PLAYERS };\n\n        for i in 0..max_players_to_encode {\n            // Encode section_id for player i at index 2*i\n            encoded[2 * i] = self.all_players_public_view[i].section_id as Field;\n            // Encode status for player i at index 2*i + 1\n            encoded[2 * i + 1] = self.all_players_public_view[i].status as Field;\n            // Role is private and not encoded here.\n            // Player ID is implicitly known by index.\n        }\n        // Indices from max_players_to_encode*2 up to 63 remain 0.\n        encoded\n    }\n}\n\n// Adapted MoveHashes\npub struct MoveHashes {\n    pub input_game_state_hash: Field, // Hash of GameState before move\n    pub input_user_state_hash: Field, // Hash of UserState before move\n    pub output_game_state_hash: Field, // Hash of GameState after move\n    pub output_user_state_hash: Field, // Hash of UserState after move\n}\n\nimpl std::default::Default for MoveHashes {\n    fn default() -> Self {\n        MoveHashes {\n            input_game_state_hash: 0,\n            input_user_state_hash: 0,\n            output_game_state_hash: 0,\n            output_user_state_hash: 0,\n        }\n    }\n}\n\n// --- Core Functions (Mirrors fog_of_war_chess structure) ---\n\n// Public move function: takes current state, user state, move data, and player index\n// Returns the new global state and relevant hashes\n#[export]\npub fn move(\n    input_state: GameState,    // Changed: Removed 'mut', renamed to input_state\n    user_state: UserState,\n    move_data: MoveData\n) -> (GameState, MoveHashes) { // Return type remains the same\n\n    let player_index = user_state.my_player_index;\n    // Calculate input hashes\n    let input_game_state_hash = input_state.hash();\n    // Placeholder for user state hash calculation\n    let input_user_state_buffer = [user_state.private_info.encrypt_secret, user_state.private_info.mask_secret];\n    let input_user_state_hash = Poseidon2::hash(input_user_state_buffer, 2);\n\n    // 1. Assertions and Pre-conditions\n    assert_eq(input_state.game_ended, false, \"Game already ended\");\n    //assert_eq(user_state.my_player_index, player_index, \"UserState does not match player_index\");\n    // Ensure the player making the move is alive in their own view\n    let my_public_info_view = user_state.all_players_public_view[player_index];\n    assert(my_public_info_view.status == STATUS_ALIVE, \"Cannot move when dead\"); // Check against constant\n\n    // 2. Validate Move Legality (using internal module)\n    let current_section = my_public_info_view.section_id;\n    let target_section = move_data.target_section;\n    let is_valid = validate_adjacent_move(current_section, target_section, MAP_SIZE); // Re-use validation\n    assert(is_valid, \"Invalid move: Target section not adjacent\"); // Assert the result\n\n    // 3. Calculate *Intended* Next Player State (for commitment)\n    // This calculates what the user_state *would* look like after the move,\n    // primarily for determining visibility for the commitment mask.\n    // It does NOT modify the input user_state.\n    let mut intended_next_user_state = user_state; // Start with current state\n    intended_next_user_state.all_players_public_view[player_index].section_id = target_section; // Update position\n    intended_next_user_state.visible_sections = calculate_visible_sections(target_section, MAP_SIZE); // Update vision\n\n    // 4. Prepare MPC Commitment Data\n    // Encode the player's *intended* view of the public state after the move\n    let encoded_state_to_commit: [Field; 64] = intended_next_user_state.encode_state_for_commitment();\n\n    // Create visibility mask based on the *intended* post-move state\n    let mut visibility_fields: [Field; 64] = [0; 64]; // 0 = hide, 1 = reveal\n    for i in 0..NUM_PLAYERS { // Iterate through all players (global indices)\n        let opponent_global_index = i;\n        let opponent_section = intended_next_user_state.all_players_public_view[opponent_global_index].section_id;\n        let mut opponent_is_visible = false;\n        for j in 0..MAX_VISIBLE_SECTIONS {\n            if intended_next_user_state.visible_sections[j] == opponent_section {\n                opponent_is_visible = true;\n            }\n        }\n\n        // If the opponent is visible *or* if it's the player themselves, mark their fields revealable\n        if opponent_is_visible | (opponent_global_index == player_index) {\n             // Mark section_id (index 2*i) and status (index 2*i + 1) as revealable\n            visibility_fields[2 * opponent_global_index] = 1;\n            visibility_fields[2 * opponent_global_index + 1] = 1;\n        }\n    }\n    // Ensure player always reveals their own info\n    if player_index < NUM_PLAYERS { // Basic bounds check\n        visibility_fields[2 * player_index] = 1;     // Reveal own section\n        visibility_fields[2 * player_index + 1] = 1; // Reveal own status\n    }\n\n    // 5. Create MPC Commitments\n    let mut output_commitments: UserOutputState<64, NUM_PLAYERS> = create_round_commitments(\n        encoded_state_to_commit,\n        visibility_fields,\n        user_state.private_info.encrypt_secret, // Use secrets from the *input* user_state\n        user_state.private_info.mask_secret,\n        input_state.mpc_state, // Pass the *immutable* input mpc_state\n        player_index\n    );\n\n    // 6. Calculate the next MPC state using the input state's mpc_state\n    let mut output_mpc_state = input_state.mpc_state;\n    //.update2(output_commitments, player_index);\n\n    output_mpc_state.round_number += 1;\n    output_mpc_state.previous_output_states[player_index] = output_commitments;\n\n    // 7. Create the output GameState\n    // Create a mutable copy of the public player info to update it\n    let mut updated_all_players_public = input_state.all_players_public;\n    updated_all_players_public[player_index].section_id = target_section;\n\n    let output_game_state = GameState {\n        all_players_public: updated_all_players_public, // Use the updated copy\n        game_ended: input_state.game_ended, // For now, assume move doesn't end game\n        mpc_state: output_mpc_state,        // Use the newly calculated MPC state\n        turn_count: input_state.turn_count + 1, // Increment turn count\n    };\n\n    // 8. Calculate Output Hashes\n    let output_game_state_hash = output_game_state.hash();\n    // User state hash should reflect the state *before* consumption,\n    // which is encoded in `encoded_state_to_commit`.\n    let output_user_state_hash = Poseidon2::hash(encoded_state_to_commit, encoded_state_to_commit.len());\n\n    // 9. Return updated global state and hashes\n    let move_hashes = MoveHashes {\n        input_game_state_hash: input_game_state_hash,\n        input_user_state_hash: input_user_state_hash, // Hash of input user state secrets\n        output_game_state_hash: output_game_state_hash, // Hash of the new game state\n        output_user_state_hash: output_user_state_hash, // Hash of the committed user view\n    };\n\n    (output_game_state, move_hashes)\n}\n\n// Initializer for GameState\n#[export]\npub fn empty_game_state() -> GameState {\n     GameState::default() // IMPLICIT return\n}\n\n// Initializer for UserState\n#[export]\npub fn initialize_user_state(player_index: u32, encrypt_secret: Field, mask_secret: Field) -> UserState {\n    let my_role = if player_index < 2 { ROLE_IMPOSTER } else { ROLE_CREW };\n    let initial_global_state = GameState::default();\n    let my_start_section = initial_global_state.all_players_public[player_index].section_id;\n    let initial_visible_sections = calculate_visible_sections(my_start_section, MAP_SIZE);\n    let mut initial_view = [PlayerPublicInfo::default(); NUM_PLAYERS];\n    \n    for i in 0..NUM_PLAYERS {\n        let other_player_global_info = initial_global_state.all_players_public[i];\n        let other_player_section = other_player_global_info.section_id;\n        let mut player_can_be_seen = false; \n        for j in 0..MAX_VISIBLE_SECTIONS {\n             if initial_visible_sections[j] == other_player_section {\n                 player_can_be_seen = true;\n             }\n        }\n\n        if i == player_index {\n            initial_view[i] = other_player_global_info;\n        } else { \n            if player_can_be_seen {\n                 initial_view[i] = other_player_global_info;\n            } else {\n                let mut masked_info = PlayerPublicInfo::default();\n                masked_info.game_player_index = i; \n                masked_info.section_id = MAP_SIZE * MAP_SIZE; \n                masked_info.status = other_player_global_info.status; \n                initial_view[i] = masked_info; \n            }\n        }\n    }\n\n    let user_state = UserState {\n        my_player_index: player_index,\n        private_info: PlayerPrivateInfo { \n            role: my_role, \n            encrypt_secret: encrypt_secret, \n            mask_secret: mask_secret, \n            voted_for_index: NUM_PLAYERS \n        },\n        encrypt_secret: encrypt_secret, \n        mask_secret: mask_secret,\n        all_players_public_view: initial_view, \n        visible_sections: initial_visible_sections,\n    };\n    \n     user_state \n}\n\n// Function to update a player's local UserState based on the global GameState's MPC commitments\n#[export]\npub fn consume_global_state_and_update_local_view(\n    current_local_user_state: UserState, \n    global_game_state: GameState,      \n) -> UserState {                        \n\n    let my_player_index = current_local_user_state.my_player_index;\n\n    // --- Consume Commitments --- \n    let revealed_state_data_nested: [[Option<Field>; 64]; NUM_PLAYERS - 1] = consume_round_commitments(\n        current_local_user_state.mask_secret, \n        global_game_state.mpc_state,             \n        my_player_index \n    );\n\n    // --- Update View --- \n    let mut updated_user_state = current_local_user_state;\n    \n    // Keep track of which opponent index maps to which nested array index\n    let mut opponent_array_index = 0; \n\n    for opponent_global_index in 0..NUM_PLAYERS {\n        if opponent_global_index != my_player_index {\n            // Get the revealed Option<Field> array for this specific opponent\n            let revealed_opponent_options: [Option<Field>; 64] = revealed_state_data_nested[opponent_array_index];\n            \n            // Get a mutable reference to our current view of this opponent\n            let mut current_opponent_view = updated_user_state.all_players_public_view[opponent_global_index];\n\n            // Decode revealed section_id (encoded at index 2 * opponent_global_index)\n            let section_index = 2 * opponent_global_index;\n            if section_index < 64 { // Bounds check\n                if revealed_opponent_options[section_index].is_some() {\n                    // Revealed: Update section_id in our view\n                    current_opponent_view.section_id = revealed_opponent_options[section_index].unwrap_unchecked() as u32;\n                } // else: Not revealed, keep existing section_id view (potentially masked/stale)\n            }\n\n            // Decode status (encoded at index 2 * opponent_global_index + 1)\n            let status_index = section_index + 1;\n            if status_index < 64 { // Bounds check\n                if revealed_opponent_options[status_index].is_some() {\n                    // Revealed: Update status in our view\n                    current_opponent_view.status = revealed_opponent_options[status_index].unwrap_unchecked() as u32;\n                } // else: Not revealed, keep existing status view (potentially masked/stale)\n            }\n\n            // NOTE: Other fields (indices not 2*i or 2*i+1) were not encoded in the first place,\n            // so we don't need to decode them.\n\n            // --- Update the main view array with the potentially updated opponent view ---\n            updated_user_state.all_players_public_view[opponent_global_index] = current_opponent_view;\n            \n            // Increment index for the revealed_state_data_nested array\n            opponent_array_index += 1;\n        }\n    }\n\n    // --- Update Our Own Public View Info ---\n    // Ensure our own view reflects the latest public global state for ourselves,\n    // as our state isn't revealed via consume_round_commitments.\n    updated_user_state.all_players_public_view[my_player_index] = global_game_state.all_players_public[my_player_index];\n\n    // --- Recalculate Visibility --- \n    let my_updated_section = updated_user_state.all_players_public_view[my_player_index].section_id;\n    updated_user_state.visible_sections = calculate_visible_sections(my_updated_section, MAP_SIZE);\n\n    // --- Optional: Re-masking based on new visibility (can be complex) ---\n    // This logic might be needed if players can move *out* of view and their info should be hidden again.\n    // For now, we rely on the initial decoding providing the correct visible state.\n\n    // --- Return Updated State --- \n    updated_user_state \n}\n","path":"/Users/lago/Desktop/joaolago1113/fogofwarr/zk_amongus/src/lib.nr"}},"names":["commit_to_user_secrets"],"brillig_names":[]}